<a href="05.md">next</a>

<h2>Promises</h2>

<h3>Создание</h3>

<div>
Позволяет обрабатывать результаты асинхронных операций так,
как если бы они были синхронными.
Объект содержащий свое состояние.
Состояний этих 3.
<ol>
<li>
Pending(ожидание)
</li>
<li>
Resolved / Fulfilled(успешно выполнен)
</li>
<li>
Rejected(не выполнен)
</li>
</ol>

Состояние Промиса неизменно и назад не возвращается.
В объекте Промиса есть метод <code>then</code>, при помощи которого
навешиваются обработчики. Метод принимает 2 аргумента, первый это
функция в которую попадет код если Промис будет исполнен успешно,
второй - не успешно.

<br/>

Однако второй аргумент как правило не используют, заменяя его
конструкцией <code>catch</code> (равнозначно: <code>.then(null, onRejected)</code>)

</div>

<div>
Создание.
Конструктор <code>Promise</code> с функцией в качестве аргумента, которая
в свою очередь содержит 2 аргумента отвечающих за выполненное(resolve)
и не выполненное состояние(reject).
</div>

<div>
<br/>
<img src="./media/04-1.png">
</div>

<div>
Условие в примере перевело Промис в состояние <code>resolved</code>, и сработал
обработчик переведя код в then. Теперь попадем в блок catch.
</div>

<div>
<br/>
<img src="./media/04-2.png">
</div>

<br/>
<div>
Обратите внимание, что в catch код попадет как из-за вызова 
  внутри Промиса функции reject() так и после генерации ошибки(в любом месте Промиса).
</div>
<br/>

<div>
<br/>
<img src="./media/04-3.png">
</div>

<div>
При последовательных вызовах (.then…then…then) в каждый следующий then переходит результат от предыдущего,
<strong>сохраняя последовательность</strong>. <a href="https://codepen.io/paawel/pen/yrNwVx?editors=0012">Пример</a>.
Описанное называют цепью вызовов. При возникновении ошибки, на любом из участков цепи, выполнение
кода перейдет в блок catch. <a href="https://codepen.io/paawel/pen/XQbGLJ?editors=0011">Пример</a>.
</div>

<br/>
<a href="03.md">prev</a>
<br/>
<a href="00.md">plan</a>
