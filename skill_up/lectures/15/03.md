<h2>Timeout and Interval</h2>

<div>
Суть таймера в возможности задерживать исполнение части кода на заданное разработчиком время.
Время задается в миллисекундах (1 секунда = 1000 миллисекунд).

<div>
<code>
setTimeout(); clearTimeout();
</code>
<br/>
<code>
setInterval(); clearInterval();
</code>
</div>

</div>

<br/>

<ul>
<li>
Таймер не часть стандарта ES, он является по сути специальным <strong>методом объекта window</strong>, для работы в среде браузера.
</li>
<li>
Код установленный в таймере может сработать <strong>только тогда, когда остальные операции выполнены и поток исполнения свободен</strong>.
(однопоточность js)
</li>
<li>
Таймеры выстраиваются в очередь (при конфликте их исполнения) и <strong>ни один таймер не может прервать выполнение другого</strong>.
По общему правилу (которое может варьироваться от браузера) очередь организуется по принципу:
"первым пришел - первым обслужен" (FIFO ‘first in - first out’, существует также обратный принцип LIFO - ‘last in - first out’).
</li>
<li>
У таймера существует минимальная задержка, устанавливаемая самим браузером (до 4 мс в зависимости от браузера).
</li>
</ul>

<div>
Разберем классическую <a href="https://codepen.io/paawel/pen/gEyYGJ?editors=1012">задачу</a>. Что выведет код ниже:

<br/>
<img src="./media/02-1.png">

<br/>

В очередь попали 4 таймера каждый из которых ссылается на переменную i, которая к моменту окончания цикла равна 4-ке.
Добится ожидаемого результата возможно объявив i через let, а не var, let создает изолированную область видимости для блоков
с фигурными скобками.

</div>

<h2>clearTimeout</h2>

<div>
Метод setTimeout возвращает числовой идентификатор таймера.

<br/>

Удалить таймер можно передав этот самый идентификатор в clearTimeout или clearInterval соответственно.

<a href="02.md">prev</a>
<br/>
<a href="00.md">plan</a>
